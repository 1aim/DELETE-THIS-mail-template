use std::fmt::{self, Display};
use std::path::{Path, PathBuf};
use std::ops::Deref;
use std::cmp::PartialEq;
use std::io;
use std::ffi::{OsStr, OsString};

use failure::{Fail, Backtrace, Context};

#[derive(Debug, Fail)]
pub enum Error<RE: Fail> {
    #[fail(display = "unknown template id: {:?}", template_id)]
    UnknownTemplateId {
        template_id: String,
        backtrace: Backtrace
    },

    #[fail(display = "{}", _0)]
    RenderError(RE),
}

impl<RE: Fail> Error<RE> {

    pub fn from_unknown_template_id<I>(tid: I) -> Self
        where I: Into<String>
    {
        Error::UnknownTemplateId {
            template_id: tid.into(),
            backtrace: Backtrace::new()
        }
    }
}

#[derive(Debug)]
pub struct LoadingSpecError {
    inner: Context<LoadingSpecErrorVariant>
}

impl LoadingSpecError {

    pub fn variant(&self) -> &LoadingSpecErrorVariant {
        self.inner.get_context()
    }
}
impl Fail for LoadingSpecError {
    fn backtrace(&self) -> Option<&Backtrace> {
        self.inner.backtrace()
    }

    fn cause(&self) -> Option<&Fail> {
        self.inner.cause()
    }
}

impl Display for LoadingSpecError {
    fn fmt(&self, fter: &mut fmt::Formatter) -> fmt::Result {
        Display::fmt(&self.inner, fter)
    }
}

impl From<LoadingSpecErrorVariant>for LoadingSpecError {
    fn from(variant: LoadingSpecErrorVariant) -> Self {
        LoadingSpecError::from(Context::new(variant))
    }
}

impl From<Context<LoadingSpecErrorVariant>> for LoadingSpecError {
    fn from(inner: Context<LoadingSpecErrorVariant>) -> Self {
        LoadingSpecError { inner }
    }
}

impl From<io::Error> for LoadingSpecError {
    fn from(io_err: io::Error) -> Self {
        io_err.context(LoadingSpecErrorVariant::IoError).into()
    }
}



#[derive(Debug, Fail)]
pub enum LoadingSpecErrorVariant {

    #[fail(display = "path must also be valid string, got: {}", _0)]
    NonStringPath(DisplayPath),

    #[fail(display =  "no type info in settings for: {:?}", type_name)]
    MissingTypeInfo { type_name: String },

    #[fail(display = "media type creation for body failed")]
    BodyMediaTypeCreationFailure,

    #[fail(display = "media type creation for Embedding/Attachment failed")]
    ResourceMediaTypeCreationFailure,

    #[fail(display = "multiple embeddings with the in-template name {:?} where found", name)]
    DuplicateEmbeddingName { name: String },

    #[fail(display = "template dir has to contain at last one sub-template. dir: {}", dir)]
    NoSubTemplatesFound { dir: DisplayPath },

    #[fail(display = "sub-template folder does not contain a template file: {}", dir)]
    TemplateFileMissing { dir: DisplayPath },

    #[fail(display = "I/O Error occurred when loading the spec")]
    IoError,

    #[fail(display = "the template/embedding/attachment <{}> is not a file", _0)]
    NotAFile(DisplayPath),

    #[fail(display = "given file does not have a valid (i.e. us-ascii/utf8) file stem: {}", _0)]
    NoValidFileStem { file: DisplayPath },

    #[fail(display = "no media type is registered for the file stem {:?}", stem)]
    NoMediaTypeFor { stem: String },

    #[fail(display = "stem and content type differ: {:?} != {:?} wrt. {}",
        by_extension, by_content, path)]
    FileStemAndContentDifferInMediaType {
        path: DisplayPath,
        by_extension: String,
        by_content: String
    },

    #[fail(display = "media type is not valid utf-8")]
    NonUtf8MediaType,

    #[fail(display = "the media type generated by a media type sniffer is invalid")]
    NotAMediaType,

    #[fail(display = "the spec with the id {:?} was overriden through a load_from_* function", id)]
    AccidentalSpecOverride { id: String },

    #[fail(display = "constructing a IRI with the scheme {} and the path {} failed", scheme, tail)]
    IRIConstructionFailed {
        scheme: &'static str,
        tail: DisplayPath
    }
}


#[derive(Clone, Debug, PartialEq, Eq, Hash)]
pub struct DisplayPath(pub PathBuf);

impl DisplayPath {
    pub fn as_path(&self) -> &Path {
        self.0.as_path()
    }
}

impl Display for DisplayPath {
    fn fmt(&self, fter: &mut fmt::Formatter) -> fmt::Result {
        Display::fmt(&self.0.display(), fter)
    }
}

impl<'a> From<&'a OsStr> for DisplayPath {
    fn from(path: &'a OsStr) -> Self {
        DisplayPath(Path::new(path).to_owned())
    }
}

impl<'a> From<&'a Path> for DisplayPath {
    fn from(path: &'a Path) -> Self {
        DisplayPath(PathBuf::from(path))
    }
}

impl From<PathBuf> for DisplayPath {
    fn from(path: PathBuf) -> Self {
        DisplayPath(path)
    }
}

impl From<OsString> for DisplayPath {
    fn from(path: OsString) -> Self {
        DisplayPath(path.into())
    }
}

impl From<DisplayPath> for PathBuf {
    fn from(dp: DisplayPath) -> Self {
        dp.0
    }
}

impl AsRef<Path> for DisplayPath {
    fn as_ref(&self) -> &Path {
        self
    }
}

impl Deref for DisplayPath {
    type Target = Path;

    fn deref(&self) -> &Self::Target {
        self.as_path()
    }
}

impl PartialEq<Path> for DisplayPath {

    fn eq(&self, other: &Path) -> bool {
        self.as_path() == other
    }
}

impl<'a> PartialEq<&'a Path> for DisplayPath {
    fn eq(&self, other: &&'a Path) -> bool {
        self == *other
    }
}

impl PartialEq<PathBuf> for DisplayPath {

    fn eq(&self, other: &PathBuf) -> bool {
        self.as_path() == other
    }
}